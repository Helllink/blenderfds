import time, sys, logging, bpy, os
from bpy.types import Scene, Object, Material
from bpy.props import IntVectorProperty
from ..config import MAXLEN
from ..types import BFNamelist, FDSList, BFNotImported
from .. import utils

log = logging.getLogger(__name__)


def _get_collection(context, name=None):
    if name:
        co = bpy.data.collections.get(name)
        if co and not context.scene.user_of_id(co):
            co.name = f"{name}.001"  # rename existing
            co = None  # not the right one
        if not co:
            co = bpy.data.collections.new(name=name)
            context.scene.collection.children.link(co)
    else:
        co = context.scene.collection
    return co


def _import(context, sc, fds_list, fds_label=None, set_collection=True) -> str:
    """!
    Import all namelists with label fds_label from fds_list into scene.
    """
    texts = list()
    while True:
        # Init
        fds_namelist = fds_list.get_fds_label(fds_label=fds_label, remove=True)
        if not fds_namelist:
            break
        is_imported = False
        bf_namelist = BFNamelist.get_subclass(fds_label=fds_namelist.fds_label)

        # Manage
        if bf_namelist:  # managed?
            hid = f"New {fds_namelist.fds_label}"  # default hid

            # Scene
            if bf_namelist.bpy_type == Scene:
                try:
                    bf_namelist(element=sc).from_fds(context, fds_namelist=fds_namelist)
                    is_imported = True
                except BFNotImported as err:
                    texts.append(str(err))

            # Object
            elif bf_namelist.bpy_type == Object:
                me = bpy.data.meshes.new(hid)  # new Mesh
                ob = bpy.data.objects.new(hid, object_data=me)  # new Object
                co_name = (
                    set_collection  # user requests
                    and f"New {bf_namelist.collection}"
                    or None
                )
                co = _get_collection(context, name=co_name)
                co.objects.link(ob)  # link to collection
                try:
                    ob.from_fds(context, fds_namelist=fds_namelist)
                    is_imported = True
                except BFNotImported as err:
                    texts.append(str(err))

            # Material
            elif bf_namelist.bpy_type == Material:
                ma = bpy.data.materials.new(hid)  # new Material
                try:
                    ma.from_fds(context, fds_namelist=fds_namelist)
                    is_imported = True
                except BFNotImported as err:
                    texts.append(str(err))

            # Unhandled
            else:
                raise AssertionError(f"Unhandled bf_namelist for <{fds_namelist}>")

        # Last resort, import to Free Text
        if not is_imported:
            texts.append(fds_namelist.to_string(context))

    # Finally, write free text
    sc.bf_config_text.write("\n".join(texts))


class BFScene:
    """!
    Extension of Blender Scene.
    """

    @property
    def bf_namelists(self):
        """!
        Return related bf_namelist, instance of BFNamelist.
        """
        return (n(element=self) for n in BFNamelist.subclasses if n.bpy_type == Scene)

    def to_fds_list(self, context, full=False) -> FDSList:
        """!
        Return the FDSList instance from self, never None.
        """
        # Set mysef as the right Scene instance in the context
        # It is needed, because context.scene is needed elsewhere
        bpy.context.window.scene = self  # set context.scene

        fds_list = FDSList()

        # Header
        if full:
            bfv = sys.modules["blenderfds"].bl_info["version"]
            blv = bpy.app.version_string
            now = time.strftime("%a, %d %b %Y, %H:%M:%S", time.localtime())
            bl_filepath = utils.io.shorten(
                bpy.data.filepath or "not saved", max_len=MAXLEN - 8, start_part=0.0
            )
            fds_list.msgs.extend(
                (
                    f"! Generated by BlenderFDS {bfv[0]}.{bfv[1]}.{bfv[2]} on Blender {blv}",
                    f"! Date: {now}",
                    f"! File: {bl_filepath}",
                )
            )

        # Scene namelists
        fds_list.append(
            FDSList(
                msg=f"--- Case from Blender Scene <{self.name}> and View Layer <{context.view_layer.name}>",
                iterable=(
                    bf_namelist.to_fds_list(context)
                    for bf_namelist in self.bf_namelists
                    if bf_namelist
                ),
            )
        )

        # Free text
        if self.bf_config_text:
            name = self.bf_config_text.name
            text = self.bf_config_text.as_string()
            if text:
                fds_list.append(
                    FDSList(msg=f"\n--- Free text from Blender Text <{name}>\n{text}")
                )

        if full:
            # Material namelists
            mas = list(
                set(  # related to Scene + use_fake_user
                    ms.material
                    for ob in self.objects
                    for ms in ob.material_slots
                    if ms.material
                ).union(ma for ma in bpy.data.materials if ma.use_fake_user)
            )
            mas.sort(key=lambda k: k.name)  # alphabetic sorting by name
            mas = (ma.to_fds_list(context=context) for ma in mas)
            if any(mas):
                fds_list.append(
                    FDSList(
                        msg="\n--- Boundary conditions from Blender Materials",
                        iterable=mas,
                    )
                )

            # Geometric collections
            fds_list.append(
                FDSList(
                    msg="\n--- Geometric namelists from Blender Collections",
                    iterable=self.collection.to_fds_list(context),
                )
            )

            # TAIL
            if self.bf_head_export:
                fds_list.append(FDSList(msg="\n&TAIL /\n"))

        return fds_list

    def to_fds(self, context, full=False, save=False):
        """!
        Return the FDS formatted string.
        @param context: the Blender context.
        @param full: if True, return full FDS case.
        @param save: if True, save to disk.
        @return FDS formatted string (eg. "&OBST ID='Test' /"), or None.
        """
        text = self.to_fds_list(context=context, full=full).to_string(context=context)
        if save:
            filepath = utils.io.transform_rbl_to_abs(
                filepath_rbl=self.bf_config_directory,
                name=self.name,
                extension=".fds",
            )
            utils.io.write_txt_file(filepath, text)
        return text

    def from_fds(self, context, filepath=None, f90=None, set_collection=True):
        """!
        Set self.bf_namelists from FDSList, on error raise BFException.
        @param context: the Blender context.
        @param filepath: filepath of FDS case to be imported.
        @param f90: FDS formatted string of namelists, eg. "&OBST ID='Test' /\n&TAIL /".
        @param set_collection: set default collection for imported geometric namelists.
        """
        # Set mysef as the right Scene instance in the context
        # this is used by context.scene calls elsewhere
        # Also for visibility
        context.window.scene = self

        # Init
        fds_list = FDSList()

        # Set filepath, instead of f90
        if filepath:
            filepath = utils.io.transform_rbl_to_abs(filepath)
            f90 = utils.io.read_txt_file(filepath=filepath)
            # and set imported fds case dir, because others rely on it
            # it is emptied later
            self.bf_config_directory = os.path.dirname(filepath)

        # Load fds case
        fds_list.from_fds(f90=f90)

        # Prepare free text for unmanaged namelists
        if not self.bf_config_text:
            self.bf_config_text = utils.ui.get_text_in_editor(
                context=context,
                text=None,
                name="New Text",
            )
        else:
            self.bf_config_text.current_line_index = 0  # rewind

        # Import by fds_label
        fds_labels = "HEAD", "SURF", "MOVE", "MULT", "MESH", "OBST", "GEOM", None
        for fds_label in fds_labels:
            _import(
                context=context,
                sc=self,
                fds_list=fds_list,
                fds_label=fds_label,
                set_collection=set_collection,
            )

        # Unlink from fds case dir, to avoid overwriting imported case
        if filepath:
            self.bf_config_directory = ""

    @classmethod
    def register(cls):
        """!
        Register related Blender properties.
        @param cls: class to be registered.
        """
        Scene.bf_namelists = cls.bf_namelists
        Scene.to_fds_list = cls.to_fds_list
        Scene.to_fds = cls.to_fds
        Scene.from_fds = cls.from_fds
        Scene.bf_file_version = IntVectorProperty(
            name="BlenderFDS File Version", size=3
        )

    @classmethod
    def unregister(cls):
        """!
        Unregister related Blender properties.
        @param cls: class to be unregistered.
        """
        del Scene.bf_file_version
        del Scene.from_fds
        del Scene.to_fds
        del Scene.to_fds_list
        del Scene.bf_namelists
