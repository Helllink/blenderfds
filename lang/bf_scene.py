import time, sys, logging, bpy, os
from bpy.types import Scene, Object, Material
from bpy.props import IntVectorProperty
from ..config import MAXLEN
from ..types import BFNamelist, FDSList, BFNotImported
from .. import utils

log = logging.getLogger(__name__)

# sc.to_fds_list() helpers


def _free_text_to_fds_list(sc, fds_list):
    if sc.bf_config_text:
        name = sc.bf_config_text.name
        text = sc.bf_config_text.as_string()
        msg = f"\n--- Free text from Blender Text <{name}>\n{text}"
        fds_list.append(FDSList(msg=msg))


def _header_to_fds_list(sc, fds_list):
    bfv = sys.modules["blenderfds"].bl_info["version"]
    blv = bpy.app.version_string
    now = time.strftime("%a, %d %b %Y, %H:%M:%S", time.localtime())
    bl_filepath = utils.io.shorten(
        bpy.data.filepath or "not saved", max_len=MAXLEN - 8, start_part=0
    )
    msgs = (
        f"! Generated by BlenderFDS {bfv[0]}.{bfv[1]}.{bfv[2]} on Blender {blv}",
        f"! Date: {now}",
        f"! File: {bl_filepath}",
    )
    fds_list.msgs.extend(msgs)


def _sc_to_fds_list(context, sc, fds_list):
    msg = f"--- Case from Blender Scene <{sc.name}> and View Layer <{context.view_layer.name}>"
    iterable = (  # Scene namelists
        bf_namelist.to_fds_list(context)
        for bf_namelist in sc.bf_namelists
        if bf_namelist
    )
    fds_list.append(FDSList(iterable=iterable, msg=msg))


def _mas_to_fds_list(context, sc, fds_list):
    header = "\n--- Boundary conditions from Blender Materials"
    mas = list(
        set(  # related to Scene + use_fake_user
            ms.material for ob in sc.objects for ms in ob.material_slots if ms.material
        ).union(ma for ma in bpy.data.materials if ma.use_fake_user)
    )
    mas.sort(key=lambda k: k.name)  # alphabetic sorting by name
    iterable = (ma.to_fds_list(context=context) for ma in mas)
    fds_list.append(FDSList(header=header, iterable=iterable))


def _cos_to_fds_list(context, sc, fds_list):
    fds_list.append(
        FDSList(
            header="\n--- Geometric namelists from Blender Collections",
            iterable=sc.collection.to_fds_list(context),
        )
    )


# sc.from_fds() helpers


def _get_co(sc, name=None):
    if name:
        co = bpy.data.collections.get(name)
        if co and not sc.user_of_id(co):  # not in current scene?
            co.name = f"{name}.001"  # rename existing
            co = None  # not the right one
        if not co:
            co = bpy.data.collections.new(name=name)
            sc.collection.children.link(co)
    else:
        co = sc.collection
    return co


def _import_sc(context, sc, bf_namelist, fds_namelist, texts):
    is_imported = False
    try:
        bf_namelist(element=sc).from_fds(context=context, fds_namelist=fds_namelist)
        is_imported = True
    except BFNotImported as err:
        texts.append(str(err))
    return is_imported


def _import_ob(context, sc, bf_namelist, fds_namelist, hid, set_collection, texts):
    is_imported = False
    me = bpy.data.meshes.new(hid)  # new Mesh
    ob = bpy.data.objects.new(hid, object_data=me)  # new Object
    co_name = (
        set_collection and f"New {bf_namelist.collection}" or None  # user requests
    )
    co = _get_co(sc=sc, name=co_name)
    co.objects.link(ob)  # link to collection
    try:
        ob.from_fds(context, fds_namelist=fds_namelist)
        is_imported = True
    except BFNotImported as err:
        texts.append(str(err))
    return is_imported


def _import_ma(context, sc, fds_namelist, hid, texts):
    is_imported = False
    ma = bpy.data.materials.new(hid)  # new Material
    try:
        ma.from_fds(context, fds_namelist=fds_namelist)
        is_imported = True
    except BFNotImported as err:
        texts.append(str(err))
    return is_imported


def _import(context, sc, fds_list, fds_label=None, set_collection=True) -> str:
    """!
    Import all namelists with label fds_label from fds_list into scene.
    """
    texts = list()
    while True:
        fds_namelist = fds_list.get_fds_label(fds_label=fds_label, remove=True)
        if not fds_namelist:
            break
        # Manage
        bf_namelist = BFNamelist.get_subclass(fds_label=fds_namelist.fds_label)
        is_imported = False
        if bf_namelist:
            hid = f"New {fds_namelist.fds_label}"
            if bf_namelist.bpy_type == Scene:
                is_imported = _import_sc(
                    context=context,
                    sc=sc,
                    bf_namelist=bf_namelist,
                    fds_namelist=fds_namelist,
                    texts=texts,
                )
            elif bf_namelist.bpy_type == Object:
                is_imported = _import_ob(
                    context=context,
                    sc=sc,
                    bf_namelist=bf_namelist,
                    fds_namelist=fds_namelist,
                    hid=hid,
                    set_collection=set_collection,
                    texts=texts,
                )
            elif bf_namelist.bpy_type == Material:
                is_imported = _import_ma(
                    context=context,
                    sc=sc,
                    fds_namelist=fds_namelist,
                    hid=hid,
                    texts=texts,
                )
            else:
                raise AssertionError(f"Unhandled bf_namelist for <{fds_namelist}>")
        # Last resort, import to Free Text
        if not is_imported:
            texts.append(fds_namelist.to_string())
    # Finally, write free text
    sc.bf_config_text.write("\n".join(texts))


class BFScene:
    """!
    Extension of Blender Scene.
    """

    @property
    def bf_namelists(self):
        """!
        Return related bf_namelist, instance of BFNamelist.
        """
        return (n(element=self) for n in BFNamelist.subclasses if n.bpy_type == Scene)

    def to_fds_list(self, context, full=False) -> FDSList:
        """!
        Return the FDSList instance from self, never None.
        """
        # Set mysef as the right Scene instance in the context
        # It is needed, because context.scene is needed elsewhere
        bpy.context.window.scene = self  # set context.scene
        fds_list = FDSList()

        if full:
            _header_to_fds_list(sc=self, fds_list=fds_list)

        _sc_to_fds_list(context=context, sc=self, fds_list=fds_list)

        if self.bf_config_text_position == "START":
            _free_text_to_fds_list(sc=self, fds_list=fds_list)

        if full:
            _mas_to_fds_list(context=context, sc=self, fds_list=fds_list)

        if self.bf_config_text_position == "SURF":
            _free_text_to_fds_list(sc=self, fds_list=fds_list)

        if full:
            _cos_to_fds_list(context=context, sc=self, fds_list=fds_list)

        if self.bf_config_text_position == "END":
            _free_text_to_fds_list(sc=self, fds_list=fds_list)

        if full and self.bf_head_export:
            fds_list.append(FDSList(msg="\n&TAIL /\n"))

        return fds_list

    def to_fds(self, context, full=False, save=False):
        """!
        Return the FDS formatted string.
        @param context: the Blender context.
        @param full: if True, return full FDS case.
        @param save: if True, save to disk.
        @return FDS formatted string (eg. "&OBST ID='Test' /"), or None.
        """
        text = self.to_fds_list(context=context, full=full).to_string()
        if save:
            filepath = utils.io.transform_rbl_to_abs(
                context=context,
                filepath_rbl=self.bf_config_directory,
                name=self.name,
                extension=".fds",
            )
            utils.io.write_txt_file(filepath, text)
        return text

    def from_fds(self, context, filepath=None, f90=None, set_collection=True):
        """!
        Set self.bf_namelists from FDSList, on error raise BFException.
        @param context: the Blender context.
        @param filepath: filepath of FDS case to be imported.
        @param f90: FDS formatted string of namelists, eg. "&OBST ID='Test' /\n&TAIL /".
        @param set_collection: set default collection for imported geometric namelists.
        """
        # Set mysef as the right Scene instance in the context
        # this is used by context.scene calls elsewhere
        # Also for visibility
        context.window.scene = self

        # Init
        fds_list = FDSList()

        # Set filepath, instead of f90
        if filepath:
            filepath = utils.io.transform_rbl_to_abs(
                context=context,
                filepath_rbl=filepath,
            )
            f90 = utils.io.read_txt_file(filepath=filepath)
            # and set imported fds case dir, because others rely on it
            # it is restored later
            bf_config_directory = self.bf_config_directory
            self.bf_config_directory = os.path.dirname(filepath)

        # Load fds case
        fds_list.from_fds(f90=f90)

        # Prepare free text for unmanaged namelists, no rewind
        if not self.bf_config_text:
            self.bf_config_text = utils.ui.get_text_in_editor(
                context=context,
                text=None,
                name="New Text",
            )

        # Import by fds_label
        fds_labels = (
            "HEAD",
            "CATF",
            "SURF",
            "MOVE",
            "MULT",
            "MESH",
            "OBST",
            "GEOM",
            None,
        )
        for fds_label in fds_labels:
            _import(
                context=context,
                sc=self,
                fds_list=fds_list,
                fds_label=fds_label,
                set_collection=set_collection,
            )

        # Restore fds case dir, to avoid overwriting imported case
        if filepath:
            self.bf_config_directory = bf_config_directory

    @classmethod
    def register(cls):
        """!
        Register related Blender properties.
        @param cls: class to be registered.
        """
        Scene.bf_namelists = cls.bf_namelists
        Scene.to_fds_list = cls.to_fds_list
        Scene.to_fds = cls.to_fds
        Scene.from_fds = cls.from_fds
        Scene.bf_file_version = IntVectorProperty(
            name="BlenderFDS File Version", size=3
        )

    @classmethod
    def unregister(cls):
        """!
        Unregister related Blender properties.
        @param cls: class to be unregistered.
        """
        del Scene.bf_file_version
        del Scene.from_fds
        del Scene.to_fds
        del Scene.to_fds_list
        del Scene.bf_namelists
