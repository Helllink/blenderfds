import time, sys, logging, bpy, os
from bpy.types import Scene, Object, Material
from bpy.props import IntVectorProperty
from ..types import BFNamelist, FDSCase, BFException, BFNotImported
from .. import utils

log = logging.getLogger(__name__)


def _import(context, sc, fds_case, fds_label=None) -> str:
    """!
    Import all namelists with label fds_label from fds_case into scene.
    """
    texts = list()
    while True:
        # Init
        fds_namelist = fds_case.get_fds_namelist(fds_label=fds_label, remove=True)
        if not fds_namelist:
            break
        is_imported = False
        bf_namelist = BFNamelist.get_subclass(fds_label=fds_namelist.fds_label)

        # Manage
        if bf_namelist:  # managed?
            hid = f"New {fds_namelist.fds_label}"  # default hid
            if bf_namelist.bpy_type == Scene:
                try:
                    bf_namelist(element=sc).from_fds(context, fds_namelist=fds_namelist)
                    is_imported = True
                except BFNotImported as err:
                    texts.append(err.to_fds())
            elif bf_namelist.bpy_type == Object:
                me = bpy.data.meshes.new(hid)  # new Mesh
                ob = bpy.data.objects.new(hid, object_data=me)  # new Object
                sc.collection.objects.link(ob)  # link it to Scene Collection
                try:
                    ob.from_fds(context, fds_namelist=fds_namelist)
                    is_imported = True
                except BFNotImported as err:
                    texts.append(err.to_fds())
            elif bf_namelist.bpy_type == Material:
                ma = bpy.data.materials.new(hid)  # new Material
                try:
                    ma.from_fds(context, fds_namelist=fds_namelist)
                    is_imported = True
                except BFNotImported as err:
                    texts.append(err.to_fds())
            else:
                raise AssertionError(f"Unhandled bf_namelist for <{fds_namelist}>")

        # Last resort, import to Free Text
        if not is_imported:
            texts.append(fds_namelist.to_fds(context))

    # Finally, write free text
    sc.bf_config_text.write("\n".join(texts))


class BFScene:
    """!
    Extension of Blender Scene.
    """

    @property
    def bf_namelists(self):
        """!
        Return related bf_namelist, instance of BFNamelist.
        """
        return (n(element=self) for n in BFNamelist.subclasses if n.bpy_type == Scene)

    def to_fds(self, context, full=False, save=False):
        """!
        Return the FDS formatted string.
        @param context: the Blender context.
        @param full: if True, return full FDS case.
        @param all_surfs: if True, return all SURF namelists, even if not related.
        @param save: if True, save to disk.
        @return FDS formatted string (eg. "&OBST ID='Test' /"), or None.
        """
        lines = list()
        # Set mysef as the right Scene instance in the context
        # It is needed, because context.scene is needed elsewhere
        bpy.context.window.scene = self  # set context.scene

        # Header
        if full:
            bfv = sys.modules["blenderfds"].bl_info["version"]
            blv = bpy.app.version_string
            now = time.strftime("%a, %d %b %Y, %H:%M:%S", time.localtime())
            blend_filepath = bpy.data.filepath or "not saved"
            if len(blend_filepath) > 60:
                blend_filepath = "···" + blend_filepath[-57:]
            lines.extend(  # header has !!!
                (
                    f"!!! Generated by BlenderFDS {bfv[0]}.{bfv[1]}.{bfv[2]} on Blender {blv}",
                    f"!!! Date: <{now}>",
                    f"!!! File: <{blend_filepath}>",
                )
            )

        # Scene namelists
        name, vl_name = self.name, context.view_layer.name
        sc_txt = FDSCase(
            fds_namelists=(
                bf_namelist.to_fds_namelist(context)
                for bf_namelist in self.bf_namelists
                if bf_namelist
            )
        ).to_fds(context=context)
        lines.append(
            f"! --- Case from Blender Scene <{name}> and View Layer <{vl_name}>"
        )
        lines.append(sc_txt)

        # Free text
        if self.bf_config_text:
            name = self.bf_config_text.name
            text = self.bf_config_text.as_string()
            if text:
                lines.append(f"\n! --- Free text from Blender Text <{name}>")
                lines.append(text)

        # Material namelists, Collections
        if full:
            mas = set(  # related to scene
                ms.material
                for ob in self.objects
                for ms in ob.material_slots
                if ms.material
            )
            mas = mas.union(  # mas with use_fake_user
                ma for ma in bpy.data.materials if ma.use_fake_user
            )
            mas = list(mas)
            mas.sort(key=lambda k: k.name)  # alphabetic sorting by name
            mas = tuple(ma.to_fds(context) for ma in mas)
            if any(mas):
                lines.append("\n! --- Boundary conditions from Blender Materials")
                lines.extend(mas)

            text = self.collection.to_fds(context)
            if text:
                lines.append("\n! --- Geometric namelists from Blender Collections")
                lines.append(text)

            # TAIL
            if self.bf_head_export:
                lines.append("\n&TAIL /\n ")

        # Write and return
        text = "\n".join(l for l in lines if l)
        if save:
            filepath = utils.io.transform_rbl_to_abs(
                filepath_rbl=self.bf_config_directory, name=self.name, extension=".fds"
            )
            utils.io.write_txt_file(filepath, text)
        return text

    def from_fds(self, context, filepath=None, f90=None):
        """!
        Set self.bf_namelists from FDSCase, on error raise BFException.
        @param context: the Blender context.
        @param filepath: filepath of FDS case to be imported.
        @param f90: FDS formatted string of namelists, eg. "&OBST ID='Test' /\n&TAIL /".
        """
        # Set mysef as the right Scene instance in the context
        # this is used by context.scene calls elsewhere
        # Also for visibility
        context.window.scene = self

        # Init
        fds_case = FDSCase()

        # Set filepath
        if filepath:
            filepath = utils.io.transform_rbl_to_abs(filepath)
            # Set imported fds case dir, because others rely on it
            # it is emptied later
            self.bf_config_directory = os.path.dirname(filepath)
            fds_case.from_fds(filepath=filepath)
        else:
            fds_case.from_fds(f90=f90)

        # Prepare free text for unmanaged namelists
        if not self.bf_config_text:
            self.bf_config_text = utils.ui.get_text_in_editor(
                context, text=None, name="Imported Text"
            )
        else:
            # Rewind to first line
            self.bf_config_text.current_line_index = 0

        # Import SURFs first to new materials
        _import(
            context=context,
            sc=self,
            fds_case=fds_case,
            fds_label="SURF",
        )

        # Import MOVEs and MULTs before geometries
        _import(
            context=context,
            sc=self,
            fds_case=fds_case,
            fds_label="MOVE",
        )
        _import(
            context=context,
            sc=self,
            fds_case=fds_case,
            fds_label="MULT",
        )

        # Import OBSTs before VENTs
        _import(
            context=context,
            sc=self,
            fds_case=fds_case,
            fds_label="OBST",
        )

        # Import all other namelists to Object or Scene
        _import(
            context=context,
            sc=self,
            fds_case=fds_case,
            fds_label=None,
        )

        # Unlink from fds case dir, to avoid overwriting imported case
        if filepath:
            self.bf_config_directory = ""

    @classmethod
    def register(cls):
        """!
        Register related Blender properties.
        @param cls: class to be registered.
        """
        Scene.bf_namelists = cls.bf_namelists
        Scene.to_fds = cls.to_fds
        Scene.from_fds = cls.from_fds
        Scene.bf_file_version = IntVectorProperty(
            name="BlenderFDS File Version", size=3
        )

    @classmethod
    def unregister(cls):
        """!
        Unregister related Blender properties.
        @param cls: class to be unregistered.
        """
        del Scene.bf_file_version
        del Scene.from_fds
        del Scene.to_fds
        del Scene.bf_namelists
